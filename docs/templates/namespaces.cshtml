@using FSharp.MetadataFormat
@{
  Layout = "template";
  Title = "Namespaces - " + Properties["project-name"];
}

<h1>@Model.Name</h1>

@{
    var namespaceDefinitions = new Dictionary<string, string>
    {
        {"bedrock", "Low-level utility routines."},
        {"bedrock.collections", "Collection classes not in the .Net framework"},
        {"bedrock.io", "Input/output classes"},
        {"bedrock.net", "Async network access"},
        {"bedrock.util", "General utilities"},
        {"jabber", "Jabber-specific classes"},
        {"jabber.client", "Client connection oriented classes"},
        {"jabber.connection", "Base classes for client and service connections"},
        {"jabber.protocol", "Jabber protocol implementation"},
        {"jabber.protocol.accept", "jabber:component:accept namespace, for services."},
        {"jabber.protocol.client", "jabber:client namespace. The meat of the protocol."},
        {"jabber.protocol.iq", "The jabber:iq:* namespaces."},
        {"jabber.protocol.stream", "etherx namespace. stream:stream and friends."},
        {"jabber.protocol.x", "The jabber:x:* namespaces."},
        {"jabber.server", "Service connections and utilties for extending the functionality of a Jabber server."},
        {"muzzle", "User interface elements that might be useful if doing Jabber programming."},
        {"stringprep", "Library for canonicalizing Unicode strings"},
        {"stringprep.steps", "Steps along the path to Unicode canonicalization."},
        {"stringprep.unicode", "Unicode data."},
        {"xpnet", "Partial port of James Clark's XP XML parser to .Net. See http://www.jclark.com/xml/ for more details."}
    };
    var nsIndex = 0;
}
@foreach (var ns in Model.Namespaces)
{
  nsIndex++;
  var typedNs = (Namespace)ns;
  var allCategories =
    typedNs.Types.Select(t => t.Category)
      .Concat(typedNs.Modules.Select(m => m.Category))
      .Distinct()
      .OrderBy(s => String.IsNullOrEmpty(s) ? "ZZZ" : s);
  var allByCategory =
    allCategories
      .Select((c, i) => new {
        Name = String.IsNullOrEmpty(c) ? "Other namespace members" : c,
        Index = String.Format("{0}_{1}", nsIndex, i),
        Types = typedNs.Types.Where(t => t.Category == c).ToArray(),
        Modules = typedNs.Modules.Where(m => m.Category == c).ToArray() })
      .Where(c => c.Types.Length + c.Modules.Length > 0).ToArray();
  string definition;

<h2>@ns.Name Namespace</h2>

    if (namespaceDefinitions.TryGetValue(ns.Name, out definition))
    {
        @definition
    }
    if (allByCategory.Length > 1)
    {
    <!-- If there is more than 1 category in the type, generate TOC -->
    <ul>
      @foreach (var g in allByCategory)
      {
        <li><a href="@("#section" + g.Index.ToString())">@g.Name</a></li>
      }
    </ul>
  }
  foreach(var g in allByCategory)
  {
    if (allByCategory.Length > 1)
    {
      <h3><a class="anchor" name="@("section" + g.Index)" href="#@("section" + g.Index)">@g.Name</a></h3>
    }
    <div>
    @RenderPart("part-nested", new
    {
      Types = g.Types,
      Modules = g.Modules
    })
    </div>
  }
}
